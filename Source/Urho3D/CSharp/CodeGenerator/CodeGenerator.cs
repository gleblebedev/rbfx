using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Urho3DNet
{
    [Generator]
    public class Urho3DNetSourceGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            var compilation = context.Compilation;

            INamedTypeSymbol? urho3dObject = compilation.GetTypeByMetadataName("Urho3DNet.Object");
            if (urho3dObject == null)
            {
                return;
            }

            var visitedClasses = new HashSet<string>();

            foreach (var syntaxTree in compilation.SyntaxTrees)
            {
                // Get the root of the syntax tree
                var root = syntaxTree.GetRoot();

                // Find all class declarations
                var classDeclarations = root.DescendantNodes().OfType<ClassDeclarationSyntax>();

                foreach (var classDeclaration in classDeclarations)
                {
                    var typeSymbolInfo = compilation.GetSemanticModel(classDeclaration.SyntaxTree).GetDeclaredSymbol(classDeclaration) as ITypeSymbol;

                    if (typeSymbolInfo == null)
                        continue;

                    var fullClassName = typeSymbolInfo.ToString();

                    if (!visitedClasses.Add(fullClassName))
                        continue;

                    var typeHierarchy = new List<ITypeSymbol>();

                    if (!CollectHierarchyUpTo(typeSymbolInfo, urho3dObject, typeHierarchy))
                        continue;

                    if (typeHierarchy.Count > 1)
                    {
                        typeHierarchy.Reverse();

                        var sourceBuilder = new StringBuilder();

                        var className = classDeclaration.Identifier.Text;

                        sourceBuilder.AppendLine("// <auto-generated/>");
                        if (typeSymbolInfo.ContainingNamespace != null)
                        {
                            sourceBuilder.AppendLine($"namespace {typeSymbolInfo.ContainingNamespace} {{");
                        }

                        var nestedInClasses = new List<INamedTypeSymbol>();
                        var nestedIn = typeSymbolInfo.ContainingType;
                        while (nestedIn != null)
                        {
                            nestedInClasses.Add(nestedIn);
                            nestedIn = nestedIn.ContainingType;
                        }

                        nestedInClasses.Reverse();

                        foreach (var namedTypeSymbol in nestedInClasses)
                        {
                            sourceBuilder.AppendLine($"partial class {namedTypeSymbol.Name} {{");
                        }

                        var newKeyword = (typeHierarchy.Count > 2) ? "new " : "";

                        sourceBuilder.AppendLine($"partial class {className} {{");

                        sourceBuilder.AppendLine($"    public static {newKeyword}readonly string ClassName = nameof({className});");

                        sourceBuilder.AppendLine($"    public static {newKeyword}readonly string BaseClassName = \"{typeHierarchy[1].Name}\";");

                        sourceBuilder.AppendLine($"    public static {newKeyword}readonly StringHash TypeId = new StringHash(nameof({className}));");

                        sourceBuilder.Append($"    public static new readonly StringHash[] TypeHierarchy = new []{{");
                        sourceBuilder.Append(string.Join(", ", typeHierarchy.Select(_=>$"new StringHash(\"{_.Name}\")")));
                        sourceBuilder.AppendLine("};");

                        bool hasGetTypeName = false;
                        bool hasGetTypeHash = false;
                        bool hasIsInstanceOf = false;
                        foreach (var methodSymbol in typeSymbolInfo.GetMembers().OfType<IMethodSymbol>())
                        {
                            switch (methodSymbol.Name)
                            {
                                case "GetTypeName": hasGetTypeName = true; break;
                                case "GetTypeHash": hasGetTypeHash = true; break;
                                case "IsInstanceOf": hasIsInstanceOf = true; break;
                            }
                        }

                        if (!hasGetTypeName)
                            sourceBuilder.AppendLine("    public override string GetTypeName() { return ClassName; }");

                        if (!hasGetTypeHash)
                            sourceBuilder.AppendLine("    public override StringHash GetTypeHash() { return TypeId; }");

                        if (!hasIsInstanceOf)
                        {
                            sourceBuilder.AppendLine("    public override bool IsInstanceOf(StringHash typeId) {");
                            sourceBuilder.AppendLine(
                                "        for (int i=0; i<TypeHierarchy.Length; ++i) if (TypeHierarchy[i] == typeId) return true;");
                            sourceBuilder.AppendLine("        return false;");
                            sourceBuilder.AppendLine("    }");
                        }

                        sourceBuilder.AppendLine("}");

                        foreach (var namedTypeSymbol in nestedInClasses)
                        {
                            sourceBuilder.AppendLine("}");
                        }

                        if (typeSymbolInfo.ContainingNamespace != null)
                        {
                            sourceBuilder.AppendLine("}");
                        }

                        context.AddSource($"{fullClassName}.g.cs", sourceBuilder.ToString());
                    }
                }
            }
        }

        private bool CollectHierarchyUpTo(ITypeSymbol? namedType, INamedTypeSymbol baseType, List<ITypeSymbol> typeHierarchy)
        {
            if (namedType == null)
                return false;

            if (SymbolEqualityComparer.Default.Equals(baseType, namedType))
            {
                typeHierarchy.Add(namedType);
                return true;
            }

            if (CollectHierarchyUpTo(namedType.BaseType, baseType, typeHierarchy))
            {
                typeHierarchy.Add(namedType);
                return true;
            }

            return  false;
        }

        public static bool TryGetParentSyntax<T>(SyntaxNode? syntaxNode, out T? result) where T : SyntaxNode
        {
            result = null;
            if (syntaxNode == null)
                return false;

            syntaxNode = syntaxNode.Parent;
            if (syntaxNode == null)
                return false;

            if (syntaxNode is T tResult)
            {
                result = tResult;
                return true;
            }

            return TryGetParentSyntax(syntaxNode, out result);
        }


        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for this one
        }
    }

}
